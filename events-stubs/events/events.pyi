from typing import (
    Any,
    Callable,
    Collection,
    Generic,
    Iterator,
    Protocol,
    Self,
    TypeVar,
    type_check_only,
)

class _EventSlot:
    __name__: str
    targets: list[Callable[..., Any]]

    def __init__(self, name: str) -> None: ...
    def __repr__(self) -> str: ...
    def __call__(self, *a: Any, **kw: Any) -> None: ...
    def __iadd__(self, f: Callable[..., Any]) -> Self: ...
    def __isub__(self, f: Callable[..., Any]) -> Self: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Callable[..., Any]]: ...
    def __getitem__(self, key: int) -> Callable[..., Any]: ...

class EventsException(Exception): ...

@type_check_only
class _EventSlotProtocol(Protocol):
    def __init__(self, name: str, /) -> None: ...

_E = TypeVar("_E", bound=_EventSlotProtocol, default=_EventSlot)

class Events(Generic[_E]):
    __event_slot_cls__: type[_E]
    __events__: Collection[str] | None

    def __init__(
        self, events: Collection[str] | None = None, event_slot_cls: type[_E] = ...
    ) -> None: ...
    def __getattr__(self, name: str) -> _E: ...
    def __getitem__(self, item: str) -> _E: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_E]: ...
    # Type-checking only
    # Allows Mypy to understand dynamic assignments, e.g.:
    #   events.on_event += handler
    #   events.on_event -= handler
    def __setattr__(self, name: str, value: _E, /) -> None: ...
